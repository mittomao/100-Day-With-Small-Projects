<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D LED Pixel Board with Neon Glow</title>
    <style>
        body {
            overflow: hidden;
            margin: 0;
        }
    </style>
</head>

<body>
    <script type="importmap">
    {
        "imports": {
        "three": "https://unpkg.com/three@0.181.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.181.0/examples/jsm/"
        }
    }
</script>

    <script type="module">
        import * as THREE from "three";
        import { OrbitControls } from "three/addons/controls/OrbitControls.js";
        import { RoundedBoxGeometry } from 'three/addons/geometries/RoundedBoxGeometry.js';
        import { SimplexNoise } from "three/addons/math/SimplexNoise.js";

        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';

        console.clear();

        class GlowLayer extends EffectComposer {
            constructor(renderer) {
                const target = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, {
                    type: THREE.HalfFloatType,
                    format: THREE.RGBAFormat,
                    colorSpace: THREE.SRGBColorSpace,
                    samples: 2
                })
                super(renderer, target);
                const renderScene = new RenderPass(scene, camera);

                const bloomPass = new UnrealBloomPass(
                    new THREE.Vector2(window.innerWidth, window.innerHeight),
                    0.25,
                    0.0,
                    1
                );

                const outputPass = new OutputPass();
                this.addPass(renderScene);
                this.addPass(bloomPass);
                this.addPass(outputPass);
            }
        }

        class TheGrid extends THREE.InstancedMesh {
            constructor(gridWidth, gridHeight, baseColor) {

                const g = new RoundedBoxGeometry(1, 0.25, 1, 3, 0.1);
                const m = new THREE.MeshLambertMaterial({
                    color: baseColor,
                    onBeforeCompile: shader => {
                        shader.vertexShader = `
          attribute vec4 instEmissive;
          varying vec4 vInstEmissive;
          ${shader.vertexShader}
        `.replace(
                            `#include <color_vertex>`,
                            `#include <color_vertex>
            vInstEmissive = instEmissive;
          `
                        );
                        shader.fragmentShader = `
          varying vec4 vInstEmissive;
          ${shader.fragmentShader}
        `.replace(
                            `#include <color_fragment>`,
                            `
          diffuseColor.rgb *= 1. - step(0.1, vInstEmissive.a);
          `
                        ).replace(
                            `vec3 totalEmissiveRadiance = emissive;`,
                            `vec3 totalEmissiveRadiance = vInstEmissive.rgb * vInstEmissive.a;`
                        );
                    }
                });
                super(g, m, gridWidth * gridHeight);

                this.size = new THREE.Vector2(gridWidth, gridHeight);

                this.simplex = new SimplexNoise();

                const startX = -(gridWidth - 1) * 0.5;
                const startY = -(gridHeight - 1) * 0.5;

                this.proxy = [];
                for (let y = 0; y < gridHeight; y++) {
                    for (let x = 0; x < gridWidth; x++) {
                        const proxyX = x + startX;
                        const proxyY = y + startY;
                        const proxy = new THREE.Object3D();
                        proxy.col = x;
                        proxy.row = y;
                        proxy.x = proxyX;
                        proxy.y = proxyY;
                        proxy.position.set(proxyX, 0, -proxyY).multiplyScalar(1.1);
                        proxy.updateMatrix();
                        this.proxy.push(proxy);
                    }
                }

                this.geometry.setAttribute("instEmissive", new THREE.InstancedBufferAttribute(new Float32Array(Array(gridWidth * gridHeight * 4).fill(0)), 4));

            }

            update(t) {
                // helper safe setter (tránh out-of-range khi grid thay đổi)
                const safeSetGlow = (x, y, r = 0, g = 0, b = 0, intensity = 0) => {
                    if (x >= 0 && x < this.size.x && y >= 0 && y < this.size.y) {
                        this.setGlow(x, y, r, g, b, intensity);
                    }
                };

                // update instance matrices & base per-proxy logic
                this.proxy.forEach((proxy, proxyID) => {
                    proxy.position.y = this.simplex.noise3d(proxy.row * 0.2, proxy.col * 0.2, t * 0.25) * 0.25;
                    proxy.updateMatrix();
                    this.setMatrixAt(proxyID, proxy.matrix);

                    // circles (giữ nguyên)
                    const proxyDist = Math.hypot(proxy.x, proxy.y) - (t * 7);
                    const circle = Math.abs((proxyDist % 15) + 7.5) < (0.5 * 1.1);
                    if (circle) {
                        safeSetGlow(proxy.col, proxy.row, 0, 0.5, 1, 2.5);
                    } else {
                        // reset emissive (0 intensity)
                        safeSetGlow(proxy.col, proxy.row, 0, 0, 0, 0);
                    }
                });

                // ----- LETTER PATTERNS (5x7) -----
                const M = [
                    [1, 0, 0, 0, 1],
                    [1, 1, 0, 1, 1],
                    [1, 0, 1, 0, 1],
                    [1, 0, 0, 0, 1],
                    [1, 0, 0, 0, 1],
                    [1, 0, 0, 0, 1],
                    [1, 0, 0, 0, 1],
                ];

                const A = [
                    [0, 1, 1, 1, 0],
                    [1, 0, 0, 0, 1],
                    [1, 0, 0, 0, 1],
                    [1, 1, 1, 1, 1],
                    [1, 0, 0, 0, 1],
                    [1, 0, 0, 0, 1],
                    [1, 0, 0, 0, 1],
                ];

                const O = [
                    [0, 1, 1, 1, 0],
                    [1, 0, 0, 0, 1],
                    [1, 0, 0, 0, 1],
                    [1, 0, 0, 0, 1],
                    [1, 0, 0, 0, 1],
                    [1, 0, 0, 0, 1],
                    [0, 1, 1, 1, 0],
                ];

                const D = [
                    [1, 1, 1, 0, 0],
                    [1, 0, 0, 1, 0],
                    [1, 0, 0, 1, 0],
                    [1, 0, 0, 1, 0],
                    [1, 0, 0, 1, 0],
                    [1, 0, 0, 1, 0],
                    [1, 1, 1, 0, 0],
                ];

                const E = [
                    [1, 1, 1, 1, 1],
                    [1, 0, 0, 0, 0],
                    [1, 1, 1, 1, 0],
                    [1, 0, 0, 0, 0],
                    [1, 0, 0, 0, 0],
                    [1, 0, 0, 0, 0],
                    [1, 1, 1, 1, 1],
                ];

                const V = [
                    [1, 0, 0, 0, 1],
                    [1, 0, 0, 0, 1],
                    [1, 0, 0, 0, 1],
                    [0, 1, 0, 1, 0],
                    [0, 1, 0, 1, 0],
                    [0, 0, 1, 0, 0],
                    [0, 0, 1, 0, 0],
                ];

                // ----- layout parameters -----
                const cols = this.size.x;   // 50
                const rows = this.size.y;   // 50
                const cx = Math.floor(cols / 2);

                const letterW = 5;
                const letterH = 7;
                const spacing = 1; // pixels between letters
                const lettersCount = 3;
                const totalWidth = lettersCount * letterW + (lettersCount - 1) * spacing;
                const startX = cx - Math.floor(totalWidth / 2);

                // --------------- <--- CHỈ THAY Ở ĐÂY NẾU MUỐN DI CHUYỂN -----
                // Đặt MAO lên cao hơn: giảm hệ số (ví dụ 0.12)
                const bottomRowStart = Math.floor(rows * 0.12);   // MAO top area (tweakable)
                // DEV vị trí dưới
                const topRowStart = Math.floor(rows * 0.62); // DEV lower area (tweakable)
                // ------------------------------------------------------------

                // colors / intensities
                const maoColor = { r: 1, g: 0.1, b: 0.1, i: 3.5 };
                const devColor = { r: 0.1, g: 1, b: 0.1, i: 1.5 };

                // helper to draw a pattern at (sx, sy)
                const drawPattern = (pattern, sx, sy, color) => {
                    for (let ry = 0; ry < pattern.length; ry++) {
                        for (let rx = 0; rx < pattern[0].length; rx++) {
                            if (pattern[ry][rx]) {
                                safeSetGlow(sx + rx, sy + ry, color.r, color.g, color.b, color.i);
                            }
                        }
                    }
                };

                const flipY = pattern => [...pattern].reverse();
                // DEV (flipped vertically)
                drawPattern(flipY(D), startX, bottomRowStart, devColor);
                drawPattern(flipY(E), startX + (letterW + spacing) * 1, bottomRowStart, devColor);
                drawPattern(flipY(V), startX + (letterW + spacing) * 2, bottomRowStart, devColor);
                // MAO (flipped vertically)
                drawPattern(flipY(M), startX, topRowStart, maoColor);
                drawPattern(flipY(A), startX + (letterW + spacing) * 1, topRowStart, maoColor);
                drawPattern(flipY(O), startX + (letterW + spacing) * 2, topRowStart, maoColor);



                // finally mark instance matrix needs update (matrices already updated above)
                this.instanceMatrix.needsUpdate = true;
            }




            setGlow(x, y, r = 0, g = 0, b = 0, intensity = 0) {
                const id = y * this.size.x + x;
                this.geometry.attributes.instEmissive.setXYZW(id, r, g, b, intensity);
                this.geometry.attributes.instEmissive.needsUpdate = true;
            }

        }

        const scene = new THREE.Scene();
        scene.background = new THREE.Color("#012");
        const camera = new THREE.PerspectiveCamera(45, innerWidth / innerHeight, 1, 100);
        camera.position.set(-0.25, 1, 1).setLength(20);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(devicePixelRatio);
        renderer.setSize(innerWidth, innerHeight);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        document.body.appendChild(renderer.domElement);

        let glowLayer = new GlowLayer(renderer);

        addEventListener("resize", event => {
            camera.aspect = innerWidth / innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(innerWidth, innerHeight);
            glowLayer.setSize(innerWidth, innerHeight);
        });

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        const light = new THREE.DirectionalLight(0xffffff, Math.PI * 1.5);
        light.position.setScalar(1);
        scene.add(light, new THREE.AmbientLight(0xffffff, Math.PI * 0.5));

        let grid = new TheGrid(40, 40, "#312");
        scene.add(grid)

        const clock = new THREE.Clock();
        let t = 0;

        renderer.setAnimationLoop(() => {
            const dt = clock.getDelta();
            t += dt;
            controls.update();
            grid.update(t);
            glowLayer.render();
            //renderer.render(scene, camera);
        })
    </script>
</body>

</html>