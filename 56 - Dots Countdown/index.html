<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dots Countdown</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Lora:ital,wght@0,400..700;1,400..700&display=swap"
        rel="stylesheet">
    <style>
        body {
            background-color: #24282f;
            margin: 0;
            padding: 0;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
        }

        #canvas-number {
            width: 800px;
            height: 500px;
        }
    </style>
</head>

<body>
    <canvas id="canvas-number"></canvas>
    <canvas id="canvas-dots"></canvas>

    <script src="//cdnjs.cloudflare.com/ajax/libs/gsap/1.16.1/TweenMax.min.js"></script>
    <script>
        /*
    Desc: Define inital variables
    */
        var numberStage,
            numberStageCtx,
            numberStageWidth = 800,
            numberStageHeight = 500,
            numberOffsetX,
            numberOffsetY,

            stage,
            stageCtx,
            stageWidth = window.innerWidth,
            stageHeight = window.innerHeight,
            stageCenterX = stageWidth / 2,
            stageCenterY = stageHeight / 2,

            countdownFrom = 3,
            countdownTimer = 2000,
            countdownBreak = 1000,
            countdownRunning = true,

            numberDots = 1680,

            number,
            dots = [],
            numberPixelCoordinates,
            circleRadius = 2,
            colors = [
                "255, 77, 109",    // üíï ƒê·ªè h·ªìng ƒë·∫≠m
                "255, 107, 255",   // üíú T√≠m h·ªìng neon
                "77, 166, 255",    // üíô Xanh d∆∞∆°ng s√°ng
                "77, 255, 166",    // üíö Xanh ng·ªçc
                "255, 255, 102",   // üíõ V√†ng neon
                "255, 179, 64",    // üß° Cam r·ª±c
                "255, 255, 255"    // ü§ç Tr·∫Øng tinh khi·∫øt (ƒëi·ªÉm s√°ng n·ªïi b·∫≠t)
            ];


        /*
        Desc: Init canvases & Number text
        */
        function init() {

            // Init stage which will have numbers
            numberStage = document.getElementById("canvas-number");
            numberStageCtx = numberStage.getContext('2d');
            // Set the canvas to width and height of the window
            numberStage.width = numberStageWidth;
            numberStage.height = numberStageHeight;

            // Init Stage which will have dots
            stage = document.getElementById("canvas-dots");
            stageCtx = stage.getContext('2d');
            stage.width = stageWidth;
            stage.height = stageHeight;

            // Create offset so text appears in middle of screen
            numberOffsetX = (stageWidth - numberStageWidth) / 2;
            numberOffsetY = (stageHeight - numberStageHeight) / 2;
        }

        init();


        /*
        Desc: Dot object
        */
        function Dot(x, y, color, alpha) {

            var _this = this;

            _this.x = x;
            _this.y = y;
            _this.color = color;
            _this.alpha = alpha;

            this.draw = function () {
                stageCtx.beginPath();
                stageCtx.arc(_this.x, _this.y, circleRadius, 0, 2 * Math.PI, false);
                stageCtx.fillStyle = 'rgba(' + _this.color + ', ' + _this.alpha + ')';
                stageCtx.shadowColor = `rgba(${_this.color}, 0.8)`; // m√†u ph√°t s√°ng theo dot
                stageCtx.shadowBlur = 15 + Math.random() * 25;
                stageCtx.fill();
            }

        }

        /*
        Desc: Create a certain amount of dots
        */
        for (var i = 0; i < numberDots; i++) {

            // Create a dot
            var dot = new Dot(randomNumber(0, stageWidth), randomNumber(0, stageHeight), colors[randomNumber(1, colors.length)], .3);

            // Push to into an array of dots
            dots.push(dot);

            // Animate dots
            tweenDots(dot, '', 'space');
        }


        /*
        Desc: Countdown
        */
        let texts = ["EM", "L√Ä", "C·ª¶A", "ANH", "‚ô•Ô∏è"];
        let textIndex = 0;

        function countdown() {
            if (countdownFrom <= 0) {
                // L·∫•y index trong m·∫£ng text
                let idx = Math.abs(countdownFrom);

                // N·∫øu index c√≤n trong m·∫£ng th√¨ hi·ªÉn th·ªã
                if (idx < texts.length) {
                    drawNumber(texts[idx], idx === length - 1 ? false : true);
                }

                // Khi ƒë√£ ƒë·∫øn ph·∫ßn t·ª≠ cu·ªëi c√πng (‚ô•Ô∏è) th√¨ d·ª´ng l·∫°i
                if (idx >= texts.length - 1) {
                    countdownRunning = false;
                    return; // d·ª´ng h·∫≥n, kh√¥ng gi·∫£m th√™m countdownFrom
                }
            } else {
                // Countdown s·ªë nh∆∞ c≈©
                drawNumber(countdownFrom.toString());
            }

            // Gi·∫£m s·ªë countdown (ch·ªâ khi ch∆∞a d·ª´ng)
            countdownFrom--;
        }
        countdown();


        /*
        Desc: Redraw loops
        */
        function loop() {

            stageCtx.clearRect(0, 0, stageWidth, stageHeight);

            for (var i = 0; i < dots.length; i++) {
                dots[i].draw(stageCtx);
            }

            requestAnimationFrame(loop);
        }

        loop();


        /*
        Desc: Draw number
        */
        function drawNumber(num, isText = false) {

            // Create a number on a seperate canvas
            // Use a seperate canvas thats smaller so we have less data to loop over when using getImagedata()

            //	Clear stage of previous numbers
            numberStageCtx.clearRect(0, 0, numberStageWidth, numberStageHeight);

            numberStageCtx.fillStyle = "#24282f";
            numberStageCtx.textAlign = 'center';
            numberStageCtx.font = `bold ${isText ? 300 : 418}px Lora`;
            numberStageCtx.fillText(num, 340, 400);

            var ctx = document.getElementById('canvas-number').getContext('2d');

            // getImageData(x, y, width, height)
            // note: is an exspenisve function, so make sure canvas is small as possible for what you grab
            // Returns 1 Dimensional array of pixel color value chanels
            // Red, blue, green, alpha chanel of single pixel
            // First chanel is red
            var imageData = ctx.getImageData(0, 0, numberStageWidth, numberStageHeight).data;

            // Clear number coordinated
            numberPixelCoordinates = [];

            // i is equal to total image data(eg: 480,000)
            // run while i is greater or equal to 0
            // every time we run it minus 4 from i. Do this because each pixel has 4 chanels & we are only interested in individual pixels 
            for (var i = imageData.length; i >= 0; i -= 4) {

                // If not an empty pixel
                if (imageData[i] !== 0) {

                    // i represents the position in the array a red pixel was found

                    // (i / 4 ) and percentage by width of canvas
                    // Need to divide i by 4 because it has 4 values and you need its orginal position
                    // Then you need to percentage it by the width(600) because each row contains 600 pixels and you need its relative position in that row
                    var x = (i / 4) % numberStageWidth;

                    // (i divide by width) then divide by 4
                    // Divide by width(600) first so you get the rows of pixels that make up the canvas. Then divide by 4 to get its postion within the row
                    var y = Math.floor(Math.floor(i / numberStageWidth) / 4);

                    // If position exists and number is divisble by circle plus a pixel gap then add cordinates to array. So circles do not overlap
                    if ((x && x % (circleRadius * 2 + 3) == 0) && (y && y % (circleRadius * 2 + 3) == 0)) {
                        // Push object to numberPixels array with x and y coordinates
                        numberPixelCoordinates.push({ x: x, y: y });

                    }

                }
            }

            formNumber();

        }

        function formNumber() {

            for (var i = 0; i < numberPixelCoordinates.length; i++) {

                // Loop out as many coordionates as we need & pass dots in to animate
                tweenDots(dots[i], numberPixelCoordinates[i], '');
            }

            // Break number apart
            if (countdownRunning) {
                setTimeout(function () {
                    breakNumber();
                }, countdownTimer);
            }
        }

        function breakNumber() {

            for (var i = 0; i < numberPixelCoordinates.length; i++) {
                tweenDots(dots[i], '', 'space');
            }

            if (countdownRunning) {
                // Build next number
                setTimeout(function () {
                    countdown();
                }, countdownBreak);
            }

        }


        /*
        Desc: Animate dots
        */
        function tweenDots(dot, pos, type) {

            // Move dots around canvas randomly
            if (type === 'space') {

                // Tween dot to coordinate to form number
                TweenMax.to(dot, (1.5 + Math.round(Math.random() * 100) / 100), {
                    x: randomNumber(0, stageWidth),
                    y: randomNumber(0, stageHeight),
                    alpha: 0.3,
                    ease: Cubic.easeInOut,
                    onComplete: function () {
                        tweenDots(dot, '', 'space');
                    }
                });

            } else {

                // Tween dot to coordinate to form number
                TweenMax.to(dot, (0.7 + Math.round(Math.random() * 100) / 100), {
                    x: (pos.x + numberOffsetX),
                    y: (pos.y + numberOffsetY),
                    delay: 0,
                    alpha: 1,
                    ease: Cubic.easeInOut,
                    onComplete: function () {
                    }
                });

            }
        }

        function randomNumber(min, max) {
            return Math.floor(Math.random() * (max - min) + min);
        }
    </script>
</body>

</html>